#version 450

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct Particle {
    vec4 position;
    vec4 velocity;
    vec4 color;
};

layout(binding = 0) uniform ParameterUBO {
    float deltaTime;
    float spawnEnabled; 
    float totalTime;
    float padding;
    vec3 lightColor;
    float padding2;
    vec3 emitterPos;
} ubo;

layout(std140, binding = 1) buffer ParticleBuffer {
    Particle particles[];
};

void main() {
    uint index = gl_GlobalInvocationID.x;

    vec4 pos = particles[index].position;
    vec4 vel = particles[index].velocity;

    // 1. Move
    pos.xyz += vel.xyz * ubo.deltaTime;

    // 2. Reset Logic
    if (pos.y <= -2.0) {
        // Only reset if spawning is enabled
        if (ubo.spawnEnabled > 0.5) {
            
            // FIX CLUMPING: Randomize Y start position (3.0 to 5.0)
            // We use a different seed than X/Z to ensure vertical variation
            float r_y = fract(sin(dot(vec2(index, pos.y), vec2(12.9898, 78.233))) * 43758.5453);
            pos.y = 3.0 + (r_y * 2.0); 
            
            // Randomize X and Z
            float r_x = fract(sin(dot(vec2(index, ubo.deltaTime), vec2(12.9898, 78.233))) * 43758.5453);
            pos.x = (r_x * 10.0) - 5.0; 
            
            float r_z = fract(cos(dot(vec2(index, ubo.deltaTime), vec2(4.898, 7.23))) * 23421.631);
            pos.z = (r_z * 10.0) - 5.0; 
            
            // Optional: Randomize velocity slightly to prevent future clumping
            vel.y = -1.0 - (r_y * 0.5); // Speed between -1.0 and -1.5
        }
        // If disabled, particle keeps falling forever (effectively disappearing)
    }

    particles[index].position = pos;
    particles[index].velocity = vel;
}