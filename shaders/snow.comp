#version 450

/**
 * @file snow.comp
 * @brief Compute shader for the Snow particle simulation.
 *
 * This shader simulates gentle precipitation within a spherical constraint. 
 * It implements a trigonometric sway pattern to simulate wind resistance 
 * and handles boundary enforcement to keep particles within the glass globe.
 */

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// --- Data Structures ---
struct Particle {
    vec4 position; // xyz = position, w = point size
    vec4 velocity; // xyz = velocity, w = life (age)
    vec4 color;    // rgba
};

// --- Uniform Data (Environmental State) ---
layout(binding = 0) uniform ParameterUBO {
    float deltaTime;
    float spawnEnabled; 
    float totalTime;
    float padding;
    vec3 lightColor;
    float padding2;
    vec3 emitterPos;
} ubo;

// --- Storage Buffer (Shared GPU Memory) ---
layout(std140, binding = 1) buffer ParticleBuffer {
    Particle particles[];
};

/**
 * @brief Deterministic pseudo-random hash function.
 */
float hash(float n) { 
    return fract(sin(n) * 43758.5453123); 
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    
    // Safety check: Limited to the hardcoded snow particle capacity
    if (index >= 3000) return;

    Particle p = particles[index];

    // 1. KINEMATICS WITH SWAY
    // Implements sinusoidal horizontal movement to simulate fluttering snow.
    float sway = sin(ubo.totalTime * 1.5 + float(index)) * 0.2;
    p.position.x += sway * ubo.deltaTime;
    p.position.z += cos(ubo.totalTime * 1.2 + float(index)) * 0.1 * ubo.deltaTime;
    p.position.y += p.velocity.y * ubo.deltaTime;

    // 2. STRICTOR BOUNDS ENFORCEMENT
    // Defines the spherical volume of the globe and the ground plane.
    vec3 sphereCenter = vec3(0.0, -0.3, 0.0);
    float globeRadius = 1.70; // Buffer to prevent z-fighting with glass
    float distFromCenter = length(p.position.xyz - sphereCenter);
    
    // 3. RESET TRIGGER DETECTION
    // Triggers if the flake hits the floor (-0.12) or exits the sphere.
    if (p.position.y < -0.12 || distFromCenter > globeRadius) {
        if (ubo.spawnEnabled > 0.5) {
            // 4. SPHERICAL RESPAWN LOGIC
            float seed = float(index) + ubo.totalTime;
            
            // Generate a point within the top-hemisphere volume.
            float r = (globeRadius - 0.05) * pow(hash(seed), 0.33);
            float phi = hash(seed + 1.0) * 1.57;
            float theta = hash(seed + 2.0) * 6.28318;
            
            p.position.x = r * sin(phi) * cos(theta);
            p.position.z = r * sin(phi) * sin(theta);
            p.position.y = r * cos(phi);
            p.position.xyz += sphereCenter;

            // 5. ATTRIBUTE INITIALIZATION
            // SMALLER SIZE: (0.4 to 0.8 range) for fine snowflakes.
            p.position.w = 0.4 + hash(seed + 4.0) * 0.4;
            
            // Drift velocity: Slow downward descent
            p.velocity.y = -0.3 - (hash(seed + 3.0) * 0.2);
            p.color = vec4(0.9, 0.9, 1.0, 0.8);
        } else {
            // Kill alpha if spawn is disabled to clear the scene.
            p.color.a = 0.0;
        }
    }

    // Write back updated state to global storage
    particles[index] = p;
}